\chapter{Результаты работы}
В качестве результатов работы была произведен Теоретико-множественный и теоретико-информационный анализ сложных систем в данном случае система поддержки инфраструктуры. Была разработана проблемно-ориентированных систем управления, принятия решений и оптимизации технических объектов в области обслуживания IT. В данной главе представлена модель разработанной системы, архитектура и реализация.
\section{Архитектура системы}
Архитектура системы представляет собой модульную систему. Основными компонентами системы являются:
\begin{enumerate}
	\item TU webservice
	\item CoreService
	\item DataService
	\item Reasoner
	\item ClientAgent
	\item MessageBus
\end{enumerate}
Система может работать в 2-х режимах: режим обучения и режим запроса. Вариант использования для режима обучения представлен на Рисунке \ref{img:train}. Главными действующими лицами является специалист технической поддержки (TSS), в общем случае это базовый класс Пользователь (User). Данный вариант использования имеет несколько ветвей:
\begin{itemize}
	\item communication:Train - обучение посредством коммуникации с системой специалиста технической поддержки. 
	\item communication:ProvidesSolution - в случае коммуникации в режиме обучения специалист технической поддержки должен предоставить не только сам запрос, который будет формализован системой, но также решение данного запроса. Система формализует запрос, формализует решение и создаст между ними связи
	\item communication:ProvideRequest - специалист технической поддержки вводит в систему запрос
	\item communication:MonitorsSolution - специалист технической поддержки смотрит как применяется решение, если находится проблема, то решение корректируется в CorrectSystemSolutions
\end{itemize}
\begin{figure} [h] 
  \center
  \includegraphics [scale=0.8, angle=90] {UseCaseTrain}
  \caption{Вариант использования. Обучение.} 
  \label{img:train}  
\end{figure}
Второй вариант использования это основной кейс. Главными действующими лицами системы является заказчик (Customer), в общем случае это базовый класс Пользователь (User). Он также имеет несколько ветвей:
\begin{itemize}
	\item ProvideRequest - заказчик вводит запрос в систему. Это может быть либо команда ProvideDirectInstruction, либо описание проблемы ProvideProblemDescription.
	\item communication:ProvideClarificationResponse - в случае, если система не может формализовать запрос, либо нашлось множество решений, то система запрашивает пользователя детали
	\item communication:ProvideConfirmationResponse - в случае, когда система нашла решение, она запрашивает пользователя подтверждение о том, что искомое решение решило его проблему
\end{itemize}
\subsection{Компоненты системы}
На Рисунке \ref{img:detailed_component_overview} представлена диаграмма компонентов системы. 
\begin{figure} [h] 
  \center
  \includegraphics [scale=0.5, angle=90] {detailed_component_overview}
  \caption{Диграмма компонентов} 
  \label{img:detailed_component_overview}  
\end{figure}
Взаимодействие компонентов системы показано на рисунке \ref{img:main_components_collaboration}.
\begin{figure} [h] 
  \center
  \includegraphics [scale=0.7] {main_components_collaboration}
  \caption{Диграмма взаимодействия компонентов} 
  \label{img:main_components_collaboration}  
\end{figure}
Пользователь взаимодействует с системой посредством компонента WebService \ref{WebService}. Взаимодействие происходит по следующем схеме:
\begin{enumerate}
	\item WebService получает запрос пользователя. Сохраняет запрос в Базу Знаний (Базу данных) \ref{Glossary}.
	\item WebService отправляет сообщение типа Request с информацией о запросе в компонент MessageBus (шина).
	\item Один из экземпляров CoreService компонента обрабатывает запрос.
	\item Компонент CoreService обрабатывает запрос и сохраняет результаты в Базу Знаний, затем он отправляет в MessageBus сообщение RequestCompleted и сообщение ActionsToExecute с действиями, которые необходимо исполнить
	\item WebService получает сообщение RequestCompleted c результатами выполнения запроса и уведомляет подписчиков (конечных пользователей)
	\item Компонент ClientAgent получает сообщение ActionsToExecute со списком действий, которые необходимо исполнить на целевых машинах
\end{enumerate}
\subsection{Компонент WebService} \label{WebService}
Данный компонент обрабатывает запросы пользователей. Запрос пользователя представляется объектом Request, который содержит информацию о пользователя, а также ссылку на метод, который будет вызван, когда запрос будет обработан. Вся работа происходит в компоненте CoreService.
На Рисунке \ref{img:web-service-interface} представлен интерфейс компонента.  
\begin{figure} [h] 
  \center
  \includegraphics [scale=1.0] {web-service-interface}
  \caption{Интерфейс компонента WebService} 
  \label{img:web-service-interface}  
\end{figure}

\begin{table} [htbp]
   \centering
   \parbox{15cm}{\caption{Описание методов}\label{Methods Description}}
%  \begin{center}
  \begin{tabular}{| p{12cm} ||p{5cm} |}
  \hline
  \hline
Метод & Описание \\
  \hline
  createRequest(request:Request):[RefObject] & Создает запрос от пользователя. В качестве параметра в метод передается SubscriptionID, по которому идет проверка запроса. \\
  
  \hline
  subscribe(user:User,subscription:Subscription)  & Создает подписку для пользователя. \\
  \hline
  unsubscribe(user:RefObject,subscription:RefObject)   & Убирает подписку пользователя. \\
  \hline
  updateSubscription(user:RefObject,subscription:Subscription)   & Обновляет подписку пользователя. \\
  \hline
  getSubscription(subscriptionID:RefObject):List<Request>    & Возвращает подписку. \\
  \hline
  findRequests(user:RefObject)     & Возвращает запросы пользователя. \\
  \hline
  createUser(user:User):RefObject     & Создает пользователя. \\
  \hline
  updateUser(user:User)     & Обновляет информацию о пользователе. \\ 
  \hline
  removeUser(user:RefObject)     & Удаляет информацию о пользователе. \\ 
  \hline
  findRequest(request:RefObject):Request     & Возвращает запрос по ссылке. \\ 
  
  \hline
  \hline
\end{tabular}
%  \end{center}
\end{table}
Подробное описание классов представлено в \ref{AppendixA}. Основной алгоритм работы компонента:
\begin{enumerate}
	\item Пользователь создает запрос, используя метод WebService.createRequest
	\item Система сохраняет запрос в Базу Знаний и начинает его обработку
	\item Когда изменяется статус запрос request.state система оповещает подписчиков на этот запрос
\end{enumerate}
\clearpage
\subsection{Компонент CoreService.ThinkingLifeCycle} \label{ThinkingLifeCycle}
Это основной компонент системы, ответственный непосредственно за выполнение запросов. Данный компонент управляет потоками, событиями приложения. Он запускает исполнение Критиков, Селекторов, Путей мышления, осуществляет обмен данных между компонентами. Компонент построен на фреймворке Akka Concurrency, который позволяет разрабатывать приложения, которые могут работать параллельно \cite{AkkaConcurrency}. \\
В данном компоненте реализовано шесть уровней мышления.
\begin{enumerate}
	\item Instinctive - Инстинктивный уровень
	\item Learned - Уровень обученных реакций
	\item Deliberative - Уровень рассуждений
	\item Reflective - Рефлексивный уровень
	\item Self-Reflective Thinking - Саморефлексивный уровень
	\item Self-Conscious Reflection - Самосознательный уровень
\end{enumerate}

На уровне Instinctive идет обработка сгенерированных по шаблону инцидентов.
Объект, который используется для обработки использует паттерн Akka \cite{AkkaConcurrency}. На рисунке \ref{img:thinking-life-cycle-cd} представлена диграмма классов компонента. 
\begin{figure} [h] 
  \center
  \includegraphics [scale=1.0,angle=90] {thinking-life-cycle-cd}
  \caption{Диаграмма классов ThinkingLifeCycle} 
  \label{img:thinking-life-cycle-cd}  
\end{figure}

\subsubsection{Описание методов класса}
\emph{onMessage(message : Message)} \\
Данный метод вызывается при получении сообщения от шины. После этого происходит обработка запроса, вычисляется список действий, которые нужно выполнить. После этого запускается исполнение этих действий. На рисунке \ref{img:thinking-life-cycle-on-message-ad} представлена диаграмма действий для этого метода.
\begin{figure} [h] 
  \center
  \includegraphics [scale=1.0] {thinking-life-cycle-on-message-ad}
  \caption{Диаграмма действий nnMessage} 
  \label{img:thinking-life-cycle-on-message-ad}  
\end{figure}

\emph{sendMessage(publisher: Publisher, message: Message): Boolean} \\
Данный метод используется для создания и отправки сообщения в шину. На рисунке \ref{img:thinking-life-cycle-send-message-publisher-publisher-ad} представлена диаграмма действий для этого метода.
\begin{figure} [h] 
  \center
  \includegraphics [scale=0.7] {thinking-life-cycle-send-message-publisher-publisher-ad}
  \caption{Диаграмма действий sendMessage} 
  \label{img:thinking-life-cycle-send-message-publisher-publisher-ad}  
\end{figure}

\emph{apply(request : Request) : List[Action]} \\
Данный метод используется для запуска обработки входящего запроса. Для запроса создается контекст, если такой уже не был создан. После этого вызывается следующий компонент системы Selector, который выбирает необходимые ресурсы из базы. На рисунке \ref{img:thinkinglifecycleapplyrequestRequestListAction} представлена диаграмма действий для этого метода.
\begin{figure} [h] 
  \center
  \includegraphics [scale=1.0] {thinkinglifecycleapplyrequestRequestListAction}
  \caption{Диаграмма действий apply} 
  \label{img:thinkinglifecycleapplyrequestRequestListAction}  
\end{figure}
Важно отметить, что метод apply является специальном методом в контексте функционального языка программирования Scala. По умолчанию при применение класса к параметрам исполняется функция apply \cite{ScalaProgrammingLanguage}.


\emph{apply(actions : List[Action]) : TransFrame} \\
Данный метод запускает обработку действий. Все действия разделяются на Critic (триггеры действий, которые в итоге должны перейти в WayToThink через Selector) и WayToThink (пути мышления, непосредственно обработчики данных, классы, которые производят изменения данных) На рисунке \ref{img:thinkinglifecycleapplyactionsListActionTransFrame} представлена диаграмма действий для этого метода.
\begin{figure} [h] 
  \center
  \includegraphics [scale=0.7] {thinkinglifecycleapplyactionsListActionTransFrame}
  \caption{Диаграмма действий apply} 
  \label{img:thinkinglifecycleapplyactionsListActionTransFrame}  
\end{figure}

\emph{processWay2Think(inputContext: Context, outputContext: Context): TransFrame} \\
Данный метод запускает обработку WayToThink \ref{Glossary}. Данный метод создает входной контекст (InputContext), заполняет его параметрами, создает выходной контекст OutputContext. Затем он запускает обработку данных во входном контексте. На рисунке \ref{img:thinkinglifecycleprocessWay2ThinkcontextContext} представлена диаграмма действий для этого метода.
\begin{figure} [h] 
  \center
  \includegraphics [scale=1.0] {thinkinglifecycleprocessWay2ThinkcontextContext}
  \caption{Диаграмма действий processWay2Think} 
  \label{img:thinkinglifecycleprocessWay2ThinkcontextContext}  
\end{figure}

\emph{processCritic(context: Context):List[SelectorRequestRulePair]} \\
Данный метод запускает обработку Critic \ref{Glossary}. На рисунке \ref{img:thinkinglifecycleactivityprocessCriticcontextContext} представлена диаграмма действий для этого метода.
\begin{figure} [h] 
  \center
  \includegraphics [scale=1.0] {thinkinglifecycleactivityprocessCriticcontextContext}
  \caption{Диаграмма действий processCritic} 
  \label{img:thinkinglifecycleactivityprocessCriticcontextContext}  
\end{figure}

\emph{init(): Boolean} \\
Данный метод инициализирует экземпляр класса ThinkingLifeCycle. Во время инициализации происходит Базы Знаний \ref{Glossary}, подключения к Шине данных. На рисунке \ref{img:thinkinglifecycleinitBoolean} представлена диаграмма действий для этого метода.
\begin{figure} [h] 
  \center
  \includegraphics [scale=1.0] {thinkinglifecycleinitBoolean}
  \caption{Диаграмма действий init} 
  \label{img:thinkinglifecycleinitBoolean}  
\end{figure}

\emph{start(): Boolean} \\
Данный метод является оберткой для поддержки Akka Concurrency. Он вызывает метод init. 

\emph{stop(): Boolean} \\
Данный метод является оберткой для поддержки Akka Concurrency. Он останавливает работу экземпляра класса: останавливается сессия к шине данных, останавливается подключение к Базе Знаний. 

\emph{registerProcess(process : Process,level : Level) : Process} \\
Данный метод регистрирует процесс в пуле. В качестве параметра принимается Level (уровень приоритета процесса). 

\emph{stop(processLevel : Level) : List[Process]} \\
Данный метод регистрирует останавливает процесс. В качестве параметра принимается ссылка на процесс. На рисунке \ref{img:thinkinglifecyclestopprocessLevelLevelListProcess} представлена диаграмма действий для этого метода.
\begin{figure} [h] 
  \center
  \includegraphics [scale=1.0] {thinkinglifecyclestopprocessLevelLevelListProcess}
  \caption{Диаграмма действий stop} 
  \label{img:thinkinglifecyclestopprocessLevelLevelListProcess}  
\end{figure}

\subsubsection{Описание работы компонента}
\emph{Запуск и остановка} \\
\begin{enumerate}
	\item Когда приложение стартует оно инициализирует ThinkingLifeCycle, который активирует набор критиков, базируясь на текущей цели системы. Например, цель-классифицировать инцидент, активируется набор критиков: разобрать, проверить, найти категорию.
	\item Когда приложение останавливается - оно останавливает все объекты класса и подклассов Actions (Critics, WayToThink), Selectors и ThinkingLifeCycle.
\end{enumerate}
Коммуникация происходит посредством сообщений, отправленных через MessageBus (Шину Данных) \ref{Glossary} JMS \cite{JMS}.
\emph{Взаимодействие компонента с другими компонентами} \\
\begin{enumerate}
	\item Критик возвращает список Селекторов (SelectorRequestRule)
	\begin{enumerate}
	\item ThinkingLifeCycle запускает обработку компонента Selector
	\item Selector возвращает список Action \ref{AppendixB} из базы знаний
	\item ThinkingLifecycle параллельно запускает возвращенные Action
	\begin{enumerate}
	\item Если Action это Critic
	\item ThinkingLifeCycle создает InputContext (входной контекст приложения) и копирует туда все данные из Context (контекста) инцидента
	\item Если Action это Critic с ссылками ReturnToSameSelector ThinkingLifeCycle ждет результаты и отправляет список SelectorRequestRule, возвращенные Critic новому Selector. Иными словами Critic может вернуть новый Selector. В данном случае нам нужно провести операцию Join для всех потоков \cite{JavaConcurrency}. В иных же случаях все Action запускаются в параллельных потоках.
	\end{enumerate} 
	\begin{enumerate}
	\item Если Action это WayToThink
	\item ThinkingLifeCycle создает InputContext (входной контекст приложения) и копирует туда все данные из Context (контекста) возвращенный Selector
	\item TLC \ref{Glossary} запускает WayToThink
	\item TLC сохраняет параметры в OutputContext
	\item TLC сохраняет итоговый результат работы и возвращает его 
	\end{enumerate} 
	\end{enumerate}
\end{enumerate}
\clearpage
\subsection{Компонент CoreService.Selector} \label{Selector}
Selector это компонент, который ответственен за получение списка действий из Базы знаний, согласно входным параметрам.
\textbf{Входной критерий}. TLC запускает Selector c параметрами. 
\textbf{Выходной критерий}. Selector получает список Action: WayToThink или Critic. \\
\subsubsection{Описание методов класса}
\begin{figure} [h] 
  \center
  \includegraphics [scale=1.0] {SelectorInterface}
  \caption{Интерфейс компонента Selector} 
  \label{img:SelectorInterface}  
\end{figure}
На Рисунке \ref{img:SelectorInterface} показан интерфейс компонента. \\

\emph{apply(request : Request) : Action} \\
Данный метод на основе запроса пользователя получает из Базы знаний необходимые Critic \ref{Critic}. На рисунке \ref{img:applyrequestRequestActionActivity} представлена диаграмма действий для этого метода.
\begin{figure} [h] 
  \center
  \includegraphics [scale=1.0] {applyrequestRequestActionActivity}
  \caption{Диаграмма действий Selector.apply} 
  \label{img:applyrequestRequestActionActivity}  
\end{figure}

\emph{apply(goal: Goal): Action} \\
Данный метод на основе цели системы получает из Базы знаний необходимые Critic \ref{Critic}. На рисунке \ref{img:applygoalGoalActionActivity} представлена диаграмма действий для этого метода.
\begin{figure} [h] 
  \center
  \includegraphics [scale=1.0] {applygoalGoalActionActivity}
  \caption{Диаграмма действий Selector.apply} 
  \label{img:applygoalGoalActionActivity}  
\end{figure}

\emph{apply(criticResult : ActionProbabilityRule) : Action} \\
Данный метод на основе работы Critic получает из Базы знаний необходимые Action \ref{Action}. На рисунке \ref{img:applycriticResultActionProbabilityRulePairActionActivity} представлена диаграмма действий для этого метода.
\begin{figure} [h] 
  \center
  \includegraphics [scale=1.0] {applycriticResultActionProbabilityRulePairActionActivity}
  \caption{Диаграмма действий Selector.apply} 
  \label{img:applycriticResultActionProbabilityRulePairActionActivity}  
\end{figure}

\subsubsection{Описание работы компонента}
\textbf{Действия при классификации инцидента}
\begin{enumerate}
	\item TLC \ref{ThinkingLifeCycle} запускает входящие Critic \ref{Critic} параллельно 
	\item Когда Critic возвращает результат работы в виде ActionProbabilityRuleTriple, TLC запускает Selector с этим параметром
	\item Selector запускает GetMostProbableWay2Think, который возвращает наиболее вероятный WayToThink
	\item В некоторых случаях Selector может вернуть менее вероятный вариант, если на Refelective уровне мышления сработал Critic, который посчитал, что данное решение некорректно или же пользователь признал его таким
\end{enumerate}
На Рисунке \ref{img:startRequestProcessingActivity} представлена диаграмма действий выбора наиболее вероятного WayToThink.
\begin{figure} [h] 
  \center
  \includegraphics [scale=0.5] {startRequestProcessingActivity}
  \caption{Диаграмма действий выбора WayToThink} 
  \label{img:startRequestProcessingActivity}  
\end{figure}
На Рисунке \ref{img:classifyIncidentActivity} представлена диаграмма действий классификации инцидента. TLC \ref{ThinkingLifeCycle} получает цель Классифицировать инцидент, затем Selector по этой цели возвращает необходимые Critic. Затем TLC запускает обработку Critic в разных потоках (параллельно). В данном случае рассматривает 3 Critic.
\begin{itemize}
	\item DirectInstruction - прямые инструкции, данный Critic возвращает WayToThink Simulate \ref{WayToThink}, который ищет связь между концепциями в запросе и концепциями в Базе Знаний.
	\item ProblemWithDesiredState - проблема с ожидаемым результатом, данный Critic возвращает Simulate+Reformulate WayToThink, которые ищут сопоставление концепциями в Базе Знаний и пытается преобразовать запрос к DirectInstruction запросу (прямым инструкциям).
	\item ProblemWithoutDesiredState - проблема без ожидаемого резульата. Данный Critic возвращает Simulate+Reformulate+InferDesiredState, который пытается преобразовать проблему к ProblemWithDesiredState.
\end{itemize}
Затем TLC собирает результаты выполнения всех Critic и запускает их по новой, пока не будет достигнута изначальная цель.\\
\begin{figure} [h] 
  \center
  \includegraphics [scale=0.6] {classifyIncidentActivity}
  \caption{Диаграмма действий классификации инцидента} 
  \label{img:classifyIncidentActivity}  
\end{figure}

\subsection{Компонент CoreService.Critics} \label{Critic}
Critic является основным компонентом для анализа в триплете Critic->Selector->WayToTHink. Critic используется для классификации входной информации, рефлексии, само-анализа и т.д. и служит своеобразным триггером.\\
\textbf{Входной критерий}\\
TLC \ref{ThinkingLifeCycle} запускает Critic согласно Goal \ref{AppendixC} (Цель) или Request. \\
\textbf{Выходной критерий}\\
Critic генерирует SelectorRequest \ref{Selector}. 
На входе Critic принимает 
\begin{itemize}
	\item Загруженные из базы правила для работы Critic (CriticRules)
	\item DomainModel:SemanticNetwork - доменная модель, представляющая собой семантическую сеть
	\item Описание инцидента, представляющая собой семантическую сеть
\end{itemize}
На выходе Critic предоставляет следующую информацию:
\begin{itemize}
	\item SelectorRequest \ref{Selector} - запрос на выбор Selector из базы знаний
	\item CriticRules - правило, которое сработало для активации. Данное правило является логическим предикатом
\end{itemize}
На Рисунку \ref{img:CriticApply} представлена диаграмма работы Critic.
\begin{figure} [h] 
  \center
  \includegraphics [scale=0.6] {CriticApply}
  \caption{Диаграмма действий работы Critic} 
  \label{img:CriticApply}  
\end{figure}
Основные типы Critic
\begin{enumerate}
	\item Manager - простой тип критика, который работает как триггер Goal \ref{AppendixC}, чтобы запустить необходимый WayToThink.
	\item Control - контролирующий Critic, который ждет определенного события (срабатывает на определенное событие). Например, заканчивается, отведенное на решение время.
	\item Analyser - анализатор, обрабатывает и выявляет тип инцидента. Например, прямые инструкции, проблема с желаемым состоянием, наиболее вероятное действие
\end{enumerate}
Основные критики
\begin{enumerate}
	\item Уровень обученных реакций
	\begin{enumerate}
		\item PreprocessManager - предобработка информации
		\item Классификаторы инцидентов: Прямые инструкции, Проблема с желаемым состоянием, Проблема без желаемого состояния
		\item SolutionCompletenessManager - связывается с пользователем и проверяет устраивает ли его найденное решение
	\end{enumerate}
	\item Уровень рассуждений
	\begin{enumerate}
		\item Выбор наиболее вероятного Selector по Rule. Данный Critic после проверки правил, выбирает из них правило с большей вероятностью
	\end{enumerate}
	\item Рефлексивный уровень
	\begin{enumerate}
		\item Менеджер целей. Установка целей
	\end{enumerate}
	\item Саморефлексивный уровень
	\begin{enumerate}
		\item ProcessingManager - запускает выполнение запроса
		\item TimeControl - контроль времени исполнения запроса
		\item DoNotUnderstandManager - активируется, когда необходимо уточнение пользователя для продолжения работы
	\end{enumerate}
	\item Самосознательный уровень
	\begin{enumerate}
		\item EmotionalStateManager - контроль общего состояния системы
	\end{enumerate} 
\end{enumerate}
\subsection{Компонент CoreService.WayToThink} \label{WayToThink}
WayToThink является основным операционным компонентом триплета Critic->Selector->WayToThink. Основными задачами данного компонента являются: обновление, преобразование, сохранение данных и коммуникация с пользователем. \\
\textbf{Входной критерий}\\
Запуска из компонента ThinkingLufeCycle \ref{ThinkingLifeCycle}. Входными данными является InputContext, который содержит параметры WayToThink.\\
\textbf{Выходной критерий}\\
WayToThink завершил работу. На выходе возвращается измененные данные в ходе работе.\\
На Рисунке \ref{img:Way2ThinkInterface} представлен интерфейс компонента. \\
\begin{figure} [h] 
  \center
  \includegraphics [scale=0.6] {Way2ThinkInterface}
  \caption{Интерфейс компонента WayToThink} 
  \label{img:Way2ThinkInterface}  
\end{figure}
В общем виде компонент описывает последовательность действий. В системе используется два больших класса WaytToThink простой и составной (сложный). Простые WayToThink являются встроенными в систему, остальные являются комбинацией компонентов: Critic \ref{Critic}, Selector \ref{Selector}, WayToThink \ref{WayToThink}.\\
Встроенные типы:
\begin{enumerate}
	\item Создать контекст
	\item Установить общий статус системы
	\item Установить цель системы
	\item Разделить фразу на слова и предложения
	\item Найти связи между входной информацией и базой знаний
	\item Извлечь связи
	\item Установить контакт с пользователями
	\item Сохранить наиболее вероятное решение
	\item Перефразировать (Reformulate)
	\item Смоделировать (Simulate)
	\item Найти решение
	\item Остановить работу
\end{enumerate}
WayToThink также используется как Решение (HowTo) \ref{AppendixDHowTo} , то есть описывает последовательность действий, необходимых для решения проблемы. 
\begin{figure} [h] 
  \center
  \includegraphics [scale=0.6] {way2thinkHowToActivity}
  \caption{Работа компонента WayToThink в режиме HowTo} 
  \label{img:way2thinkHowToActivity}  
\end{figure}

\subsection{Компонент CoreService.PreliminaryAnnotator} \label{PreliminaryAnnotator}
Данный компонент проводит предварительную подготовку текста: грамматическую и орфографическую коррекцию текста, а также разделение на предложения. На Рисунке \ref{img:PrelimenaryAnnotatorInterface} представлен интерфейс компонента. 
\begin{figure} [h] 
  \center
  \includegraphics [scale=0.6] {PrelimenaryAnnotatorInterface}
  \caption{Интерфейс компонента PrelimenaryAnnotator} 
  \label{img:PrelimenaryAnnotatorInterface}  
\end{figure}

\subsection{Компонент CoreService.KnowledgeBaseAnnotator} \label{KnowledgeBaseAnnotator}
Данный компонент устанавливает связи между терминами во входной фразе и базой знаний.  \\
\textbf{Входными критериями} является список фраз. \\
\textbf{Выходными критериями} является список ссылок на внутренние термины. \\
Поток действий:
\begin{enumerate}
	\item Получен Термин
	\item Поиск в локальной базе знаний
	\item Если совпадение не найдено идет запрос во внешнюю базу знаний
	\item Внешняя база возвращает список синонимов
	\item Компонент ищет по синонимам во внутренний базе знаний
	\item Если поиск успешен, то создается связь между входящем термином, синонимом и концепцией в базе знаний
\end{enumerate}
Например, входящий запрос содержит термин 'program', База знаний содержит термин 'computer software'. Идет запрос во внешние базы знаний, найдено computer software, program. Будет добавлена аналогия в база знаний program->computer software. 


\subsection{Компонент DataService} \label{data service}
Данный компонент отвечает за хранение данных в системе. База знаний построена на графах. На Рисунке \ref{img:KnowledgeBaseServer} представлен интерфейс компонента. В базе знаний используется два типа объектов Object - объект базы знаний, BusiessObject - объект для Web Service (User, Request). BusinessObject является кортежем для интеграции с внешними системами. У объекта есть ID, который уникально удостоверяет его в рамках системы.\\
\begin{figure} [h] 
  \center
  \includegraphics [scale=0.6] {KnowledgeBaseServer}
  \caption{Интерфейс компонента KnowledgeBaseServer} 
  \label{img:KnowledgeBaseServer}  
\end{figure}
Список методов:
\begin{enumerate}
	\item save(obj:Resource):Resource - сохранить ресурс в базу знаний
	\item remove(obj:Resource) - удалить объект
	\item select(obj:Resource):Resource - выбрать объект
	\item link(obj:List<Resource>,linkName:String) - сделать ссылку между 2-мя объектами
	\item selectLinkedObject(obj:Resource,linkName:String):Link<Resource> - выбрать все объекты, которые имеют связь под названием linkName с объектом obj.
	\item addLinkedObject(parent:Resource,toLink:Resource,linkName:String) - создать ссылку linkName с объектом
	\item saveRequest(obj:Request) - сохранить запрос в базу
	\item selectRequest(obj:RefObject) - получить запрос из Базы Знаний
	\item saveBusinessObject(obj:RefObject):RefObject - сохранить объект в базу	
	\item selectBusinessObject(obj:RefObject):RefObject - полуить объект из базы знаний
\end{enumerate}
\subsection{Компонент ClientAgent} \label{client agent}
Данный компонент предназначен для выполнения решений на конечной машине. Данный компонент должен поддерживать обработку \ref{AppendixDHowTo}. В случае проблем компонент также должен обращаться за помощью к специалисту.
\clearpage
\section{Прототип}
В прототипе были реализованы 4 уровня мышления. Основной рабочий поток приложения описан следующим алгоритмом:
\begin{enumerate}
	\item Поступает запрос от пользователя \\
	User had received wrong application.
User has ordered Wordfinder Business Economical.
However she received wrong version, she received Wordfinder Tehcnical instead of Business Economical. Please assist.
	\item GoalManger устанавливает цель системы HelpUser
	\item Активируется набор Critic, привязанный к данной цели
	\item PreliminaryAnnorator разбирает фразу
	\item KnowledgeBaseAnnotator создает семантическую сеть и ссылки на нее
	\item Critic на Рефликсивном уровне запускает WayToThink ProblemSolving с целью: ResolveIncident
	\item Critic на Рефликсивном уровне выбирает WayToThink KnowingHow
	\begin{enumerate}
	\item Запускаются параллельно все Critic, которые привязаны к IncidentClassification Critic, который привязан к ResolveIncident цели, в данном случае это DirectInstruction, ProblemWithDesiredState, ProblemWithoutDesiredState \ref{ThinkingLifeCycle}
	\item Selector выбирает наиболее вероятный результат работы среди всех результатов компонентов. В данном случае будет результат работы Problem Description with desired state.
	\item KnowingHow сохраняет варианты выбора Selector.
	\item Simulation WayToThink с параметрами Создать модель текущий ситуации создает модель CurrentSituation. User, Software
	\item Reformulation WayToThink, используя результаты предыдущего шага синтезирует артефакты, которых не хватает, чтобы получить CurrentState и DesiredState. DesiredState не указан явно. WayToThink запускает Critic размышления, чтобы найти корень проблемы. Critic размышления находит CurrentState- Wordfinder Tehcnical, DesiredState-Wordfinder Business Economical
	\item Рефлексивные Critic оценивают состояние системы - на каком шаге она находится, и если цель не достигнута, то запускают другой WayToThink, который был возвращен, например, DirectInstruction. 
	\item Critic генерации решения запускает KnowingHow \ref{AppendixDHowTo} WayToThink, ExtensiveSearch.
	\item Selector выбирает наиболее вероятный путь мышления. В данном случае ExtensiveSearch, который будет находить решения, позволяющие привести систему в необходимое состояние (DesiredState). Если он не сможет, то он иницирует коммуникацию с пользователем. 
	

	 \end{enumerate}
	 \item Рефлексивный Critic проверяет состояние системы. Если Цель достигнута, то пользователю посылается ответ.
	 \item Само Сознательные Critic активируется на данном шаге и сохраняют информацию о затратах на решение.

\end{enumerate}
\subsection{UML диаграмма действий приложения} \label{LifecycleActivity}
На Рисунке \ref{img:LifecycleActivity} представлена UML диаграма действий системы.
\begin{figure} [h] 
  \center
  \includegraphics [scale=0.18] {LifecycleActivity}
  \caption{Диаграмма действий LifecycleActivity} 
  \label{img:LifecycleActivity}  
\end{figure}
\subsection{Технологии прототипа} \label{PrototypeTechnology}
Прототип был написан на языке Scala, с применением технологии Akka - параллельного исполнения на множестве ядер. В качестве базы используется Neo4j графовая база данных. 
\clearpage
\section{Испытание прототипа}
\subsection{Экспериментальные данные}

\section{Выводы по главе}
%\newpage
%============================================================================================================================


\clearpage